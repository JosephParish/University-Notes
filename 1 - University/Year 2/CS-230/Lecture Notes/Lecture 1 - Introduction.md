#### General Course Topics: 
- Review of Life Cycle models
- Requirements Engineering
- Software design and prototyping
- Software Implementation
	- JavaFX
	- Exception Handling
	- Corner Cases
- Some Software Testing
- Design UML

#### Pre Course Info:
- Assessments are under "modules" in this module 
- Practice Java ahead of the module and revise the coding conventions for clean code :)
- This is very group work & coursework heavy.
- Examinations & Marking Weights:
	- A1 [30%] - Object Oriented Design (80s style game) 
	- A2 [45%] - Implementing the Design
	- Multiple Choice Exam [25%] - Allegedly easy?
- This module is speech heavy, look to take many notes and listen to what he is actually saying
- There's an expectation for 150 hours of study for each module. Look to actually put the time in.
- Actually show up too
- "Java for Everyone" has some great examples


#### How do we start making large software? 
- Not in one file.
- It's worth considering:
	- Appropriate theories and methodology
	- Time, Organisational and Financial constraints
	- All aspects of development
- Like any large project, software engineering requires a team.
	- Different people, different roles.
	- These roles and people may change depending on the task.
- We can organise code into something more significant using STRUCTURE!!!

#### Hardware VS Software Engineering:
- These are both very different
	- Software can be fixed / patched pretty easily and cheaply
		- Most games now are shit on launch because of this
	- Hardware cannot be fixed or patched so easily
		- Much more expensive to recall this stuff

#### Planning Software:
- All software development techniques (Agile, Scrum, Waterfall) contain at least some of the following:
	- Specification
	- Design
	- Development
	- Validation
#### As computer power increases, more complex issues can be tackled.
- There is no "one silver bullet fix" to completely prevent overruns or failures with code
- Issues arise when projects are:
	- Very Large
	- Complex
	- Poor spec
- With bigger and bigger systems, it's now cheaper to do all of the planning steps instead of slamming shit together and hoping it works.
- It's important to make code maintainable and readable as code maintenance is expensive as shit (Hence legacy software like windows 10 and java 8 is still in such high demand)