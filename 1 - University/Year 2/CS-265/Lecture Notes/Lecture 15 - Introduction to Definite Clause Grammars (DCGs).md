#### NLP on Parsing using Definite Clause Grammars: 
- Ties to previous discussion on individuals and relations
	- Jill is happy -> A sentence with a structure.
		- Jill is an individual
		- Happy is a predicate
- NLP parsing analyses the whole sentence in terms of its parts
	- Who is happy? 
		- Query for specific information.
		- happy(jill) -> Determine if true relative to a model
- Essentially NLP follows the core concept of this module. How can human knowledge be structured and implemented to enable querying and stuff.

#### Context-free Grammars:
- Prolog offers a special notation for defining grammars
	- DCGs (definite clause grammars)
- Context free grammars are a very powerful mechanism that can handle most aspects of natural languages.

#### Example of a CFG:
- Note:
	- a CFG is a set of production rules that describe all possible strings in a given formal language
	- a CFG is a formal grammar thats set up of these rules.
	- Theyre simple repacements of symbols rlly
- Example:
	- S -> NP VP
	- NP -> DET N
	- VP -> V NP
	- VP -> V
	- DET -> the
	- DET -> a
	- N -> man
	- N -> woman
	- V -> shoots
(ive made the "variables" uppercase for visiblity like in 275)

#### The Ingredients of a grammar:
- the -> symbol is used to define the rules
- The uppercase symbols s, np, vp, det, n, v are known as non-terminal symbols.
- the lowercase symbols are known as terminal symbols

#### Linguistics:
- In a linguistic grammar, the non-terminal symbol usually corresponds to grammatical categories. 
- The terminal symbols are called the lexical items (or simply words) or the alphabet


#### Context free rules:
- The above example contains 9 context free rules
- A context free rule has
	- a single non terminal symbol
	- -> 
	- a finite sequence of terminal or non terminal symbols

#### Grammar coverage:
The following:
- the woman shoots a man
is grammatical, and we can tell through making a parse tree!
![[Pasted image 20250430115325.png]]
- These are importantas they give us information about:
	- The string
	- The structure
- If we are given a string of words and a grammar, and we can build a parse tree that is epic and not shit / broken then we say that string is grammatical.
- If not, it's ungrammatical

#### Generated Language: 
- The language generated by a grammar consists of all strings that the grammar classifies as grammatical.

#### Recogniser:
- A context free recogniser is a program which correctly tells us whether a string belongs to the language generated by a context free grammar.
- AKA, a recogniser is a program that classifies strings as grammatical or ungrammatical
- PARSERs also do the exact same thing

#### Info about structure:
- Both linguistics and CS, we want to know WHY a sentence is grammatical or not
- The parse tree offers us this

#### Theory VS Practice
- So far the theory.
	- How do we make these in prolog?
- Assume we're given a context free grammar.
	- How can we make a recogniser for it? 
	- How can we make a parser for it?

#### CFG Recognition in Prolog:
- We shall use lists to represent a sequence of tokens.
	- [a,woman,shoots,a,man]
- The rule s -> np vp can be through as:
	- concatenating an np-list with a vp list
	- this would return an s-list
- We know how to concatenate lists in Prolog using append/3

#### CFG Recognition using append/3
``` Prolog
s(C):- np(A), vp(B), append(A,B,C).
np(C):-det(A),n(B), append(A,B,C).
vp(C):- v(A), np(B), append(A,B,C).
vp(C) :- v(C).
det([the]).
det([a]).
n([man]).
n([woman]).
v([shoots]).
```
So now we can query this like so:
``` PrologQuery
?- s([the,woman,shoots,a,man])
yes
?- np(X).
X = [the,man];
X = [the,woman]
```

#### Some issues with this recogniser:
- it doesnt use the input strings to guide the search
	- It tries all the combinations until it find the right one
- Goals such as np(A) and vp(B) are called with uninstantiated variables
- Moving the append/3 goals to the front is not a good idea as now theres a shit ton of append/3 calls without instantiated variables.

#### Difference Lists: 
- A more efficient implementation can be obtained by using difference lists.
- This is a sophisticated prolog technique for representing and working with lists.
- E.G:
	- [a,b,c] - [] is the list [a,b,c]
	- [a,b,c,d] - [d] is the list [a,b,c]
	- [a,b,c | T] - T is the list [a,b,c]
	- X - X is the empty list []

#### CFG Recognition using Difference Lists: 
```Prolog
s(A-C) :- np(A-B), vp(B-C).
np(A-C):- det(A-B), n(B-C)
vp(A-C):- v(A-B), np(B-C).
vp(A-C):- v(A-C).
det([the|W]-W).
det([a|W]-W),
n([man|W]-W).
n([woman|W]-W).
v([shoots|W]-W).
```
and this works like so:
```PrologQuery
?-s([the,man,shoots,a,man]-[])
```

#### RECAP: What we've done so far!
- The recogniser using difference lists is a lot more efficient than the one using append/3
- However its not easy to understand and is a pain keeping track of all those difference list variables
- It would be nice to have a recogniser as simple as the first and as efficient as the second

#### Definite Clause Grammars!
- What are they?
	- Simply theyre a nice notation for writing grammars that hide the underlying difference list variables
	- Below are some examples!
```DCG
s --> np, vp
np --> det, n.
vp --> v, np.
vp --> v.
det --> [the]
det --> [a]
n --> [man].
n --> [woman].
v --> [shoots].
```
And the query:
``` prologQuery
?-s([a,man,shoots,a,woman],[])
yes
?- s(S,[]).
S = [the,man,shoots,the,man];
S = [the,man,shoots,a,man];
...
```

#### What's going on?
- a DCG rule such as:
	- s -> np, vp.
- is really just a variant of
- S(A,B) :- np(A,C), vp(C,B).
DCGs simplify notation! :o 

#### DCGs are not magic!
- You cannot write arbitraty context free grammars as a DCG and have it run without issues.
- Theyre ordinary prolog rules in disguise
- So watch out for left-recursion

Done :)